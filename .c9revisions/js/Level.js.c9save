{"ts":1357159237651,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"Game.Level = new Class({\r\n    initialize: function(spline){\r\n        this.blockables = [];\r\n        this.powerups = [];\r\n        this.spline = this.buildSpline();\r\n        this.buildBlockables();\r\n    },\r\n    \r\n    handleSingleTick: function(){\r\n        \r\n    },\r\n    \r\n    handleCamera: function(){\r\n          \r\n    },\r\n    \r\n    alignBlockables: function(dir){\r\n          \r\n    },\r\n    \r\n    buildSpline: function(){\r\n          return null;\r\n    },\r\n    \r\n    buildMeshFromGeometry: function(geometry, color){\r\n        var tubeMesh = THREE.SceneUtils.createMultiMaterialObject(geometry, [\r\n\t\t    new THREE.MeshLambertMaterial({\r\n\t\t\t\t\t\tcolor: color,\r\n\t\t\t\t\t\topacity: (geometry.debug) ? 0.2 : 0.5,\r\n\t\t\t\t\t\ttransparent: true\r\n\t\t\t\t\t}),\r\n\t\t    new THREE.MeshBasicMaterial({\r\n\t\t\t\t\t\tcolor: color,\r\n\t\t\t\t\t\topacity: 0.5,\r\n\t\t\t\t\t\twireframe: true,\r\n                        transparent: true\r\n\t\t    })\r\n        ]);\r\n\r\n\t\tif (geometry.debug) tubeMesh.add(geometry.debug);  \r\n        return tubeMesh;\r\n    },\r\n    \r\n    buildBlockables: function(){\r\n        //this.material = new THREE.MeshPhongMaterial({color: 0xff0000, opacity: 0.8, wireframe: false, transparent: true});\r\n        this.material = new THREE.MeshBasicMaterial({color: 0xff0000});\r\n        this.blockables = [];\r\n        var geom = this.spline.children[0].geometry;\r\n        var path = geom.path;\r\n        var segments = geom.segments;\r\n        var segmentsRadius = geom.segmentsRadius;\r\n        var cylinderGeom = new THREE.CylinderGeometry( geom.radius/*radiusTop*/, geom.radius/*radiusBottom*/, 0.1/*height*/, segmentsRadius/*segmentsRadius*/, 1/*segmentsHeight*/, false/*openEnded*/ );\r\n        var availablePositions = [];\r\n        for(var j = 0; j < segmentsRadius; j++){\r\n            availablePositions.push(j);    \r\n        }\r\n        \r\n        for(var i = 0; i < segments; i++){\r\n            var directions = availablePositions.clone();\r\n            Game.Utils.arrayShuffle(directions);\r\n            \r\n            var rnd = Math.random();\r\n            if(rnd < 0.0015){\r\n                directions = directions.slice(0, -1);        // extract array from 0 to the second last (-1 = 1 counting from tail)  \r\n            }\r\n            else if(rnd < 0.005){\r\n                directions = directions.slice(0, -2);\r\n            }\r\n            else if(rnd < 0.01){\r\n                directions = directions.slice(0, -3);\r\n            }\r\n            else if(rnd < 0.02){\r\n                directions = directions.slice(0, -4);\r\n            }\r\n            else if(rnd < 0.025){\r\n                directions = directions.slice(0, -5);\r\n            }\r\n            else{\r\n                directions = [];   \r\n            }\r\n            \r\n            if(directions.length > 0){\r\n                var objects = [];\r\n                \r\n                var arcLengthPos = i/segments;\r\n                var pos = path.getPointAt(arcLengthPos);\r\n                var tangent = geom.tangents[i], normal = geom.normals[i], binormal = geom.binormals[i];\r\n                directions.each(function(dir, index){\r\n                    var obj = new THREE.Object3D();\r\n                    var mesh = new THREE.Mesh(cylinderGeom, this.material);\r\n                    mesh.rotation.x = 1.5*Math.PI;\r\n                    mesh.rotation.z = Math.PI/2;\r\n                    obj.add(mesh);\r\n                            \r\n                    // move in dir on spline\r\n                    var dirVector = Game.Utils.getVectorByDir(binormal, normal, dir, segmentsRadius);\r\n                    var offPos = pos.clone().addSelf(dirVector.normalize().multiplyScalar(1.75*geom.radius));\r\n                    obj.position.set(offPos.x, offPos.y, offPos.z);\r\n                            \r\n                    // rotate it correctly on spline\r\n                    var m = new THREE.Matrix4(tangent.x, normal.x, binormal.x, 0,\r\n                                                tangent.y, normal.y, binormal.y, 0,\r\n                                                tangent.z, normal.z, binormal.z);\r\n                    obj.rotation.getRotationFromMatrix(m);\r\n                            \r\n                    representation.scene.add(obj);\r\n                    objects[dir] = (obj); \r\n                }, this);\r\n                this.blockables[i] = objects;\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nGame.Level1 = new Class({\r\n    Extends: Game.Level,\r\n    initialize: function(){\r\n        this.parent();\r\n    },\r\n    \r\n    buildSpline: function(){\r\n        var extrudePath = new THREE.Curve();\r\n        extrudePath.getPoint = function(t) {\r\n        \tvar p = 2,\r\n    \t\t\tq = 5;\r\n    \t\tt *= Math.PI * 2;\r\n    \t\tvar tx = (2 + Math.cos(q * t)) * Math.cos(p * t),\r\n    \t\t\tty = (2 + Math.cos(q * t)) * Math.sin(p * t),\r\n    \t\t\ttz = Math.sin(q * t);\r\n    \r\n    \t\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(30.0/3);\r\n    \t}\r\n       \r\n\t    var geometry = new THREE.TubeGeometry(extrudePath, 100/*segments*/, 1/*radius*/, 6/*radiusSegments*/, true/*closed2*/, false/*debug*/);\r\n        return this.buildMeshFromGeometry(geometry, Math.random() * 0xffffff);\r\n    }\r\n});\r\n\r\nGame.Level2 = new Class({\r\n    Extends: Game.Level,\r\n    initialize: function(){\r\n        this.parent();\r\n    },\r\n    \r\n    buildSpline: function(){\r\n        this.extrudePath = new THREE.Curve();\r\n        this.extrudePath.getPoint = function(t) {\r\n            t *= 2 * Math.PI;\r\n            var tx = 16 * Math.pow(Math.sin(t), 3);\r\n        \tvar ty = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t), tz = 0;\r\n        \r\n        \treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(50.0/16);\r\n        \r\n        }\r\n       \r\n\t    var geometry = new THREE.TubeGeometry(this.extrudePath, 300/*segments*/, 1/*radius*/, 6/*radiusSegments*/, true/*closed2*/, false/*debug*/);\r\n        return this.buildMeshFromGeometry(geometry, 0x0000ff);\r\n    }\r\n});\r\n\r\n\r\n\r\n\r\n\r\n"]],"start1":0,"start2":0,"length1":0,"length2":5859}]],"length":5859}
{"contributors":[],"silentsave":false,"ts":1357159292381,"patch":[[{"diffs":[[0,"ion("],[-1,"spline){\r\n        this.blockables = [];\r\n        this.powerups = [];\r\n        this.spline = this.buildSpline();\r\n        this.buildBlockables();"],[1,"graphAsStringRepres){\r\n        this.stringRepresentation = graphAsStringRepres;\r\n        "],[0,"\r\n  "]],"start1":47,"start2":47,"length1":152,"length2":97},{"diffs":[[0,"\r\n\r\n"],[-1,"Game.Level1 = new Class({\r\n    Extends: Game.Level,\r\n    initialize: function(){\r\n        this.parent();\r\n    },\r\n    \r\n    buildSpline: function(){\r\n        var extrudePath = new THREE.Curve();\r\n        extrudePath.getPoint = function(t) {\r\n        \tvar p = 2,\r\n    \t\t\tq = 5;\r\n    \t\tt *= Math.PI * 2;\r\n    \t\tvar tx = (2 + Math.cos(q * t)) * Math.cos(p * t),\r\n    \t\t\tty = (2 + Math.cos(q * t)) * Math.sin(p * t),\r\n    \t\t\ttz = Math.sin(q * t);\r\n    \r\n    \t\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(30.0/3);\r\n    \t}\r\n       \r\n\t    var geometry = new THREE.TubeGeometry(extrudePath, 100/*segments*/, 1/*radius*/, 6/*radiusSegments*/, true/*closed2*/, false/*debug*/);\r\n        return this.buildMeshFromGeometry(geometry, Math.random() * 0xffffff);\r\n    }\r\n});\r\n\r\nGame.Level2 = new Class({\r\n    Extends: Game.Level,\r\n    initialize: function(){\r\n        this.parent();\r\n    },\r\n    \r\n    buildSpline: function(){\r\n        this.extrudePath = new THREE.Curve();\r\n        this.extrudePath.getPoint = function(t) {\r\n            t *= 2 * Math.PI;\r\n            var tx = 16 * Math.pow(Math.sin(t), 3);\r\n        \tvar ty = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t), tz = 0;\r\n        \r\n        \treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(50.0/16);\r\n        \r\n        }\r\n       \r\n\t    var geometry = new THREE.TubeGeometry(this.extrudePath, 300/*segments*/, 1/*radius*/, 6/*radiusSegments*/, true/*closed2*/, false/*debug*/);\r\n        return this.buildMeshFromGeometry(geometry, 0x0000ff);\r\n    }\r\n});\r\n\r\n\r\n\r\n"],[0,"\r\n\r\n"]],"start1":4245,"start2":4245,"length1":1559,"length2":8}]],"length":4253,"saved":false}
{"ts":1357159319600,"patch":[[{"diffs":[[0,"epres;\r\n        "],[1,"this.edges = [];\r\n        this.graph = new Graph();"],[0,"\r\n    },\r\n    \r\n"]],"start1":124,"start2":124,"length1":32,"length2":83}]],"length":4304,"saved":false}
{"ts":1357159322892,"patch":[[{"diffs":[[0,"h = new "],[1,"Game."],[0,"Graph();"]],"start1":175,"start2":175,"length1":16,"length2":21}]],"length":4309,"saved":false}
{"ts":1357159402129,"patch":[[{"diffs":[[0," = n"],[-1,"ew Game."],[1,"ull;\r\n        \r\n        this.decodeStringTo"],[0,"Grap"]],"start1":176,"start2":176,"length1":16,"length2":51}]],"length":4344,"saved":false}
{"ts":1357159471153,"patch":[[{"diffs":[[0,"    "],[-1,"handleSingleTick: function(){\r\n        \r\n    },\r\n    \r\n    handleCamera: function(){\r\n          \r\n    },\r\n    \r\n    alignBlockables: function(dir){\r\n          \r\n    },\r\n    \r\n    buildSpline: function(){\r\n          return null;\r\n    },\r\n    \r\n    buildMeshFromGeometry: function(geometry, color){\r\n        var tubeMesh = THREE.SceneUtils.createMultiMaterialObject(geometry, [\r\n\t\t    new THREE.MeshLambertMaterial({\r\n\t\t\t\t\t\tcolor: color,\r\n\t\t\t\t\t\topacity: (geometry.debug) ? 0.2 : 0.5,\r\n\t\t\t\t\t\ttransparent: true\r\n\t\t\t\t\t}),\r\n\t\t    new THREE.MeshBasicMaterial({\r\n\t\t\t\t\t\tcolor: color,\r\n\t\t\t\t\t\topacity: 0.5,\r\n\t\t\t\t\t\twireframe: true,\r\n                        transparent: true\r\n\t\t    })\r\n        ]);\r\n\r\n\t\tif (geometry.debug) tubeMesh.add(geometry.debug);  \r\n        return tubeMesh;\r\n    },\r\n    \r\n    buildBlockables: function(){\r\n        //this.material = new THREE.MeshPhongMaterial({color: 0xff0000, opacity: 0.8, wireframe: false, transparent: true});\r\n        this.material = new THREE.MeshBasicMaterial({color: 0xff0000});\r\n        this.blockables = [];\r\n        var geom = this.spline.children[0].geometry;\r\n        var path = geom.path;\r\n        var segments = geom.segments;\r\n        var segmentsRadius = geom.segmentsRadius;\r\n        var cylinderGeom = new THREE.CylinderGeometry( geom.radius/*radiusTop*/, geom.radius/*radiusBottom*/, 0.1/*height*/, segmentsRadius/*segmentsRadius*/, 1/*segmentsHeight*/, false/*openEnded*/ );\r\n        var availablePositions = [];\r\n        for(var j = 0; j < segmentsRadius; j++){\r\n            availablePositions.push(j);    \r\n        }\r\n        \r\n        for(var i = 0; i < segments; i++){\r\n            var directions = availablePositions.clone();\r\n            Game.Utils.arrayShuffle(directions);\r\n            \r\n            var rnd = Math.random();\r\n            if(rnd < 0.0015){\r\n                directions = directions.slice(0, -1);        // extract array from 0 to the second last (-1 = 1 counting from tail)  \r\n            }\r\n            else if(rnd < 0.005){\r\n                directions = directions.slice(0, -2);\r\n            }\r\n            else if(rnd < 0.01){\r\n                directions = directions.slice(0, -3);\r\n            }\r\n            else if(rnd < 0.02){\r\n                directions = directions.slice(0, -4);\r\n            }\r\n            else if(rnd < 0.025){\r\n                directions = directions.slice(0, -5);\r\n            }\r\n            else{\r\n                directions = [];   \r\n            }\r\n            \r\n            if(directions.length > 0){\r\n                var objects = [];\r\n                \r\n                var arcLengthPos = i/segments;\r\n                var pos = path.getPointAt(arcLengthPos);\r\n                var tangent = geom.tangents[i], normal = geom.normals[i], binormal = geom.binormals[i];\r\n                directions.each(function(dir, index){\r\n                    var obj = new THREE.Object3D();\r\n                    var mesh = new THREE.Mesh(cylinderGeom, this.material);\r\n                    mesh.rotation.x = 1.5*Math.PI;\r\n                    mesh.rotation.z = Math.PI/2;\r\n                    obj.add(mesh);\r\n                            \r\n                    // move in dir on spline\r\n                    var dirVector = Game.Utils.getVectorByDir(binormal, normal, dir, segmentsRadius);\r\n                    var offPos = pos.clone().addSelf(dirVector.normalize().multiplyScalar(1.75*geom.radius));\r\n                    obj.position.set(offPos.x, offPos.y, offPos.z);\r\n                            \r\n                    // rotate it correctly on spline\r\n                    var m = new THREE.Matrix4(tangent.x, normal.x, binormal.x, 0,\r\n                                                tangent.y, normal.y, binormal.y, 0,\r\n                                                tangent.z, normal.z, binormal.z);\r\n                    obj.rotation.getRotationFromMatrix(m);\r\n                            \r\n                    representation.scene.add(obj);\r\n                    objects[dir] = (obj); \r\n                }, this);\r\n                this.blockables[i] = objects;\r\n            }\r\n        }\r\n    }"],[1,"decodeStringToGraph: function(){\r\n        \r\n    }\r\n    "],[0,"\r\n})"]],"start1":247,"start2":247,"length1":4088,"length2":63}]],"length":319,"saved":false}
{"ts":1357160781389,"patch":[[{"diffs":[[0,"){\r\n        "],[1,"var c = 0;\r\n        var arr = this.stringRepresentation.split(\";\");\r\n        var dim = arr[0];"],[0,"\r\n    }\r\n   "]],"start1":281,"start2":281,"length1":24,"length2":118}]],"length":413,"saved":false}
{"ts":1357160841999,"patch":[[{"diffs":[[0,"plit(\";\");\r\n"],[1,"        if(arr.length < 1){\r\n            return;\r\n        }\r\n"],[0,"        var "]],"start1":350,"start2":350,"length1":24,"length2":85}]],"length":474,"saved":false}
{"ts":1357160953869,"patch":[[{"diffs":[[0," = arr[0];\r\n"],[1,"        if(dim != (arr.length - 1)*arr.length/2)\r\n"],[0,"    }\r\n    \r"]],"start1":438,"start2":438,"length1":24,"length2":74}]],"length":524,"saved":false}
{"ts":1357160985942,"patch":[[{"diffs":[[0,"ength/2)"],[1,"{\r\n            console.log(\"in Level:decodeStringToGraph: sizes do not match\");\r\n        }"],[0,"\r\n    }\r"]],"start1":490,"start2":490,"length1":16,"length2":106}]],"length":614,"saved":false}
{"ts":1357160994432,"patch":[[{"diffs":[[0,"t match\");\r\n"],[1,"            return;\r\n"],[0,"        }\r\n "]],"start1":567,"start2":567,"length1":24,"length2":45}]],"length":635,"saved":false}
{"ts":1357161011831,"patch":[[{"diffs":[[0,"\n        }\r\n"],[1,"        \r\n        var i = 0, j =0;\r\n"],[0,"    }\r\n    \r"]],"start1":599,"start2":599,"length1":24,"length2":60}]],"length":671,"saved":false}
{"ts":1357161055579,"patch":[[{"diffs":[[0," }\r\n"],[1,"\r\n"],[0,"        "],[-1,"\r\n"],[1,"for(var i = 0; i < dim; i++){\r\n   "],[0,"        "],[1," for("],[0,"var "],[-1,"i"],[1,"j"],[0," = 0"],[-1,", j =0;"],[1,"; j <= i; j++){\r\n            \r\n        }\r\n        }"],[0,"\r\n  "]],"start1":607,"start2":607,"length1":42,"length2":125}]],"length":754,"saved":false}
{"ts":1357161235803,"patch":[[{"diffs":[[0,"){\r\n"],[-1,"        var c = 0;\r\n"],[0,"    "]],"start1":281,"start2":281,"length1":28,"length2":8},{"diffs":[[0,"   }\r\n\r\n"],[1,"        var c = 1;\r\n"],[0,"        "]],"start1":585,"start2":585,"length1":16,"length2":36},{"diffs":[[0,"i = "],[-1,"0"],[1,"1"],[0,"; i <"],[1,"="],[0," dim"]],"start1":629,"start2":629,"length1":14,"length2":15},{"diffs":[[0,"var j = "],[-1,"0"],[1,"1"],[0,"; j <= i"]],"start1":669,"start2":669,"length1":17,"length2":17},{"diffs":[[0,"){\r\n            "],[-1,"\r\n"],[1,"    \r\n    "],[0,"        }\r\n     "]],"start1":691,"start2":691,"length1":34,"length2":42}]],"length":763,"saved":false}
{"ts":1357161253198,"patch":[[{"diffs":[[0,"   }\r\n\r\n"],[1,"        this.graph = new Game.Graph(dim);\r\n"],[0,"        "]],"start1":585,"start2":585,"length1":16,"length2":59}]],"length":806,"saved":false}
{"ts":1357161286917,"patch":[[{"diffs":[[0,"                "],[1,"this.graph.set(i,j, arr[c++]);"],[0,"\r\n            }\r"]],"start1":738,"start2":738,"length1":32,"length2":62}]],"length":836,"saved":false}
{"ts":1357161625012,"patch":[[{"diffs":[[0,"length/2"],[1," - dim){     // symmetric and no diagonal (-dim"],[0,")"],[-1,"{"],[0,"\r\n      "]],"start1":469,"start2":469,"length1":18,"length2":64},{"diffs":[[0,"= 1; j <"],[-1,"="],[0," i; j++)"]],"start1":764,"start2":764,"length1":17,"length2":16}]],"length":881,"saved":false}
{"contributors":[],"silentsave":false,"ts":1357223364407,"patch":[[{"diffs":[[0,"    "],[-1,"\r\n        this.decodeStringToGraph"],[1,"this.sphereRadius = 0;\r\n        this.vertexPositions = [];      // on unit Sphere\r\n        \r\n        this.decodeStringToGraph();\r\n        this.determineSphereRadius();\r\n        this.determineVertexPositions();\r\n        this.createEdges"],[0,"();\r"]],"start1":190,"start2":190,"length1":42,"length2":243},{"diffs":[[0,"m = "],[1,"parseInt("],[0,"arr[0]"],[1,")"],[0,";\r\n "]],"start1":618,"start2":618,"length1":14,"length2":24},{"diffs":[[0," if("],[-1,"dim != "],[0,"(arr"]],"start1":648,"start2":648,"length1":15,"length2":8},{"diffs":[[0,"ngth"],[-1," - 1)*arr.length"],[1,"-1) != ((dim+1)*dim)"],[0,"/2 -"]],"start1":659,"start2":659,"length1":24,"length2":28},{"diffs":[[0,"ot match"],[-1,"\""],[1,". Expected: \" + ( ((dim+1)*dim)/2 - dim) + \"/tgot: \" + (arr.length-1)"],[0,");\r\n    "]],"start1":800,"start2":800,"length1":17,"length2":85},{"diffs":[[0,"j = "],[1,"i+"],[0,"1; j <"],[-1," i"],[1,"= dim"],[0,"; j++){"],[1,"         // 1,2 1,3 .. 1,n 2,3 ..."],[0,"\r\n  "]],"start1":1038,"start2":1038,"length1":23,"length2":62},{"diffs":[[0,"et(i,j, "],[1,"parseInt("],[0,"arr[c++]"]],"start1":1126,"start2":1126,"length1":16,"length2":25},{"diffs":[[0,"rr[c++])"],[1,")"],[0,";\r\n     "]],"start1":1144,"start2":1144,"length1":16,"length2":17},{"diffs":[[0,"    }\r\n    }"],[1,",\r\n    \r\n    determineSphereRadius: function(){\r\n        this.sphereRadius = this.graph.dim;\r\n    },\r\n    \r\n    determineVertexPositions: function(){\r\n//        % Generate a set of evenly distributed points on a unit sphere\r\n//% using the method of the Golden Section Spiral method.\r\n//%\r\n//% Output is a 3xN matrix of points for X,Y,Z.\r\n//%\r\n//% Based on python code from Patric Boucher on http://www.xsi-blog.com\r\n//    inc = math.pi * (3 - math.sqrt(5))\r\n//    off = 2 / N\r\n//    for k in range(0, N):\r\n//        y = k * off - 1 + (off / 2)\r\n//        r = math.sqrt(1 - y*y)\r\n//        phi = k * inc\r\n//        pts.append([math.cos(phi)*r, y, math.sin(phi)*r])\r\n// \r\n//    return pts\r\n        this.vertexPositions = [];\r\n        var n = this.graph.dim;\r\n        var inc = Math.PI * (3-Math.sqrt(5));\r\n        var off = 2/n;\r\n        \r\n        for(var k = 0; k<n; k++){\r\n            var y = k*off - 1 + (off/2);\r\n            var r = Math.sqrt(1 - y*y);\r\n            var phi = k * inc;\r\n            this.vertexPositions.push(new THREE.Vector3(Math.cos(phi)*r, y, Math.sin(phi)*r));\r\n        }\r\n    },"],[0,"\r\n    \r\n});\r"]],"start1":1175,"start2":1175,"length1":24,"length2":1125}]],"length":2307,"saved":false}
{"ts":1357223382963,"patch":[[{"diffs":[[0,"rn pts\r\n"],[1,"        this.vertexPositions = [];\r\n        var n = this.graph.dim;\r\n        var inc = Math.PI * (3-Math.sqrt(5));\r\n        var off = 2/n;\r\n        \r\n        for(var k = 0; k<n; k++){\r\n            var y = k*off - 1 + (off/2);\r\n            var r = Math.sqrt(1 - y*y);\r\n            var phi = k * inc;\r\n            this.vertexPositions.push(new THREE.Vector3(Math.cos(phi)*r, y, Math.sin(phi)*r));\r\n        }\r\n    },\r\n    \r\n    createEdges: function(){\r\n\r\n"],[0,"        "]],"start1":1867,"start2":1867,"length1":16,"length2":469}]],"length":2760,"saved":false}
{"ts":1357223390533,"patch":[[{"diffs":[[0,"om\r\n"],[-1,"//    inc = math.pi * (3 - math.sqrt(5))\r\n//    off = 2 / N\r\n//    for k in range(0, N):\r\n//        y = k * off - 1 + (off / 2)\r\n//        r = math.sqrt(1 - y*y)\r\n//        phi = k * inc\r\n//        pts.append([math.cos(phi)*r, y, math.sin(phi)*r])\r\n// \r\n//    return pts"],[0,"\r\n  "]],"start1":1599,"start2":1599,"length1":278,"length2":8}]],"length":2490,"saved":false}
{"ts":1357223650017,"patch":[[{"diffs":[[0,"){\r\n"],[-1,"\r\n"],[0,"        "],[-1,"this.vertexPositions = [];\r\n        var n = this.graph.dim;\r\n        var inc = Math.PI * (3-Math.sqrt(5));\r\n        var off = 2/n;"],[1,"for(var i = 1; i <= dim; i++){"],[0,"\r\n  "]],"start1":2052,"start2":2052,"length1":148,"length2":46},{"diffs":[[0,"    "],[-1,"\r\n   "],[0,"    "],[-1," "],[0,"for(var "],[-1,"k = 0; k<n; k"],[1,"j = i+1; j <= dim; j"],[0,"++){"],[-1,"\r\n"],[0,"    "]],"start1":2100,"start2":2100,"length1":45,"length2":44},{"diffs":[[0,"    "],[-1,"   var y = k*off - 1 + (off/2);\r\n            var r = Math.sqrt(1 - y*y);\r\n            var phi = k * inc;\r\n            this.vertexPositions.push(new THREE.Vector3(Math.cos(phi)*r, y, Math.sin(phi)*r));"],[1,"// 1,2 1,3 .. 1,n 2,3 ...\r\n                this.graph.set(i,j, parseInt(arr[c++]));\r\n            }"],[0,"\r\n  "]],"start1":2145,"start2":2145,"length1":208,"length2":106}]],"length":2285,"saved":false}
{"ts":1357223674807,"patch":[[{"diffs":[[0,"\n               "],[1," var edgeAmount ="],[0," this.graph.set("]],"start1":2175,"start2":2175,"length1":32,"length2":49},{"diffs":[[0,"aph."],[-1,"s"],[1,"g"],[0,"et(i,j"],[-1,", parseInt(arr[c++]));"],[1,");\r\n                "],[0,"\r\n  "]],"start1":2216,"start2":2216,"length1":37,"length2":35}]],"length":2300,"saved":false}
{"ts":1357223690160,"patch":[[{"diffs":[[0,"                "],[1,"if(edgeAmount < 1){\r\n                    continue;\r\n                }"],[0,"\r\n            }\r"]],"start1":2231,"start2":2231,"length1":32,"length2":101}]],"length":2369,"saved":false}
{"ts":1357223710317,"patch":[[{"diffs":[[0,"             }\r\n"],[1,"                \r\n                for(var c = 0; c < edgeAmount; c++){\r\n                    \r\n                }\r\n"],[0,"            }\r\n "]],"start1":2302,"start2":2302,"length1":32,"length2":145}]],"length":2482,"saved":false}
{"ts":1357223766589,"patch":[[{"diffs":[[0,"                "],[1,"this.edges.push(new Game.EdgeModel(i,j, vertexPositions[i], vertexPositions[j]));"],[0,"\r\n              "]],"start1":2394,"start2":2394,"length1":32,"length2":113}]],"length":2563,"saved":false}
{"ts":1357223785838,"patch":[[{"diffs":[[0,"itions[j]));"],[1,"       // i < j for all i,j"],[0,"\r\n          "]],"start1":2479,"start2":2479,"length1":24,"length2":51}]],"length":2590,"saved":false}
{"ts":1357223895080,"patch":[[{"diffs":[[0,"s: function(){\r\n"],[1,"        var dim = this.dim;\r\n"],[0,"        for(var "]],"start1":2040,"start2":2040,"length1":32,"length2":61}]],"length":2619,"saved":false}
{"ts":1357224004613,"patch":[[{"diffs":[[0,"el(i,j, "],[1,"this."],[0,"vertexPo"]],"start1":2477,"start2":2477,"length1":16,"length2":21},{"diffs":[[0,"ons[i], "],[1,"this."],[0,"vertexPo"]],"start1":2502,"start2":2502,"length1":16,"length2":21}]],"length":2635,"saved":false}
