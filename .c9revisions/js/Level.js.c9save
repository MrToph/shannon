{"ts":1357159237651,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"Game.Level = new Class({\r\n    initialize: function(spline){\r\n        this.blockables = [];\r\n        this.powerups = [];\r\n        this.spline = this.buildSpline();\r\n        this.buildBlockables();\r\n    },\r\n    \r\n    handleSingleTick: function(){\r\n        \r\n    },\r\n    \r\n    handleCamera: function(){\r\n          \r\n    },\r\n    \r\n    alignBlockables: function(dir){\r\n          \r\n    },\r\n    \r\n    buildSpline: function(){\r\n          return null;\r\n    },\r\n    \r\n    buildMeshFromGeometry: function(geometry, color){\r\n        var tubeMesh = THREE.SceneUtils.createMultiMaterialObject(geometry, [\r\n\t\t    new THREE.MeshLambertMaterial({\r\n\t\t\t\t\t\tcolor: color,\r\n\t\t\t\t\t\topacity: (geometry.debug) ? 0.2 : 0.5,\r\n\t\t\t\t\t\ttransparent: true\r\n\t\t\t\t\t}),\r\n\t\t    new THREE.MeshBasicMaterial({\r\n\t\t\t\t\t\tcolor: color,\r\n\t\t\t\t\t\topacity: 0.5,\r\n\t\t\t\t\t\twireframe: true,\r\n                        transparent: true\r\n\t\t    })\r\n        ]);\r\n\r\n\t\tif (geometry.debug) tubeMesh.add(geometry.debug);  \r\n        return tubeMesh;\r\n    },\r\n    \r\n    buildBlockables: function(){\r\n        //this.material = new THREE.MeshPhongMaterial({color: 0xff0000, opacity: 0.8, wireframe: false, transparent: true});\r\n        this.material = new THREE.MeshBasicMaterial({color: 0xff0000});\r\n        this.blockables = [];\r\n        var geom = this.spline.children[0].geometry;\r\n        var path = geom.path;\r\n        var segments = geom.segments;\r\n        var segmentsRadius = geom.segmentsRadius;\r\n        var cylinderGeom = new THREE.CylinderGeometry( geom.radius/*radiusTop*/, geom.radius/*radiusBottom*/, 0.1/*height*/, segmentsRadius/*segmentsRadius*/, 1/*segmentsHeight*/, false/*openEnded*/ );\r\n        var availablePositions = [];\r\n        for(var j = 0; j < segmentsRadius; j++){\r\n            availablePositions.push(j);    \r\n        }\r\n        \r\n        for(var i = 0; i < segments; i++){\r\n            var directions = availablePositions.clone();\r\n            Game.Utils.arrayShuffle(directions);\r\n            \r\n            var rnd = Math.random();\r\n            if(rnd < 0.0015){\r\n                directions = directions.slice(0, -1);        // extract array from 0 to the second last (-1 = 1 counting from tail)  \r\n            }\r\n            else if(rnd < 0.005){\r\n                directions = directions.slice(0, -2);\r\n            }\r\n            else if(rnd < 0.01){\r\n                directions = directions.slice(0, -3);\r\n            }\r\n            else if(rnd < 0.02){\r\n                directions = directions.slice(0, -4);\r\n            }\r\n            else if(rnd < 0.025){\r\n                directions = directions.slice(0, -5);\r\n            }\r\n            else{\r\n                directions = [];   \r\n            }\r\n            \r\n            if(directions.length > 0){\r\n                var objects = [];\r\n                \r\n                var arcLengthPos = i/segments;\r\n                var pos = path.getPointAt(arcLengthPos);\r\n                var tangent = geom.tangents[i], normal = geom.normals[i], binormal = geom.binormals[i];\r\n                directions.each(function(dir, index){\r\n                    var obj = new THREE.Object3D();\r\n                    var mesh = new THREE.Mesh(cylinderGeom, this.material);\r\n                    mesh.rotation.x = 1.5*Math.PI;\r\n                    mesh.rotation.z = Math.PI/2;\r\n                    obj.add(mesh);\r\n                            \r\n                    // move in dir on spline\r\n                    var dirVector = Game.Utils.getVectorByDir(binormal, normal, dir, segmentsRadius);\r\n                    var offPos = pos.clone().addSelf(dirVector.normalize().multiplyScalar(1.75*geom.radius));\r\n                    obj.position.set(offPos.x, offPos.y, offPos.z);\r\n                            \r\n                    // rotate it correctly on spline\r\n                    var m = new THREE.Matrix4(tangent.x, normal.x, binormal.x, 0,\r\n                                                tangent.y, normal.y, binormal.y, 0,\r\n                                                tangent.z, normal.z, binormal.z);\r\n                    obj.rotation.getRotationFromMatrix(m);\r\n                            \r\n                    representation.scene.add(obj);\r\n                    objects[dir] = (obj); \r\n                }, this);\r\n                this.blockables[i] = objects;\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nGame.Level1 = new Class({\r\n    Extends: Game.Level,\r\n    initialize: function(){\r\n        this.parent();\r\n    },\r\n    \r\n    buildSpline: function(){\r\n        var extrudePath = new THREE.Curve();\r\n        extrudePath.getPoint = function(t) {\r\n        \tvar p = 2,\r\n    \t\t\tq = 5;\r\n    \t\tt *= Math.PI * 2;\r\n    \t\tvar tx = (2 + Math.cos(q * t)) * Math.cos(p * t),\r\n    \t\t\tty = (2 + Math.cos(q * t)) * Math.sin(p * t),\r\n    \t\t\ttz = Math.sin(q * t);\r\n    \r\n    \t\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(30.0/3);\r\n    \t}\r\n       \r\n\t    var geometry = new THREE.TubeGeometry(extrudePath, 100/*segments*/, 1/*radius*/, 6/*radiusSegments*/, true/*closed2*/, false/*debug*/);\r\n        return this.buildMeshFromGeometry(geometry, Math.random() * 0xffffff);\r\n    }\r\n});\r\n\r\nGame.Level2 = new Class({\r\n    Extends: Game.Level,\r\n    initialize: function(){\r\n        this.parent();\r\n    },\r\n    \r\n    buildSpline: function(){\r\n        this.extrudePath = new THREE.Curve();\r\n        this.extrudePath.getPoint = function(t) {\r\n            t *= 2 * Math.PI;\r\n            var tx = 16 * Math.pow(Math.sin(t), 3);\r\n        \tvar ty = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t), tz = 0;\r\n        \r\n        \treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(50.0/16);\r\n        \r\n        }\r\n       \r\n\t    var geometry = new THREE.TubeGeometry(this.extrudePath, 300/*segments*/, 1/*radius*/, 6/*radiusSegments*/, true/*closed2*/, false/*debug*/);\r\n        return this.buildMeshFromGeometry(geometry, 0x0000ff);\r\n    }\r\n});\r\n\r\n\r\n\r\n\r\n\r\n"]],"start1":0,"start2":0,"length1":0,"length2":5859}]],"length":5859}
{"contributors":[],"silentsave":false,"ts":1357159292381,"patch":[[{"diffs":[[0,"ion("],[-1,"spline){\r\n        this.blockables = [];\r\n        this.powerups = [];\r\n        this.spline = this.buildSpline();\r\n        this.buildBlockables();"],[1,"graphAsStringRepres){\r\n        this.stringRepresentation = graphAsStringRepres;\r\n        "],[0,"\r\n  "]],"start1":47,"start2":47,"length1":152,"length2":97},{"diffs":[[0,"\r\n\r\n"],[-1,"Game.Level1 = new Class({\r\n    Extends: Game.Level,\r\n    initialize: function(){\r\n        this.parent();\r\n    },\r\n    \r\n    buildSpline: function(){\r\n        var extrudePath = new THREE.Curve();\r\n        extrudePath.getPoint = function(t) {\r\n        \tvar p = 2,\r\n    \t\t\tq = 5;\r\n    \t\tt *= Math.PI * 2;\r\n    \t\tvar tx = (2 + Math.cos(q * t)) * Math.cos(p * t),\r\n    \t\t\tty = (2 + Math.cos(q * t)) * Math.sin(p * t),\r\n    \t\t\ttz = Math.sin(q * t);\r\n    \r\n    \t\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(30.0/3);\r\n    \t}\r\n       \r\n\t    var geometry = new THREE.TubeGeometry(extrudePath, 100/*segments*/, 1/*radius*/, 6/*radiusSegments*/, true/*closed2*/, false/*debug*/);\r\n        return this.buildMeshFromGeometry(geometry, Math.random() * 0xffffff);\r\n    }\r\n});\r\n\r\nGame.Level2 = new Class({\r\n    Extends: Game.Level,\r\n    initialize: function(){\r\n        this.parent();\r\n    },\r\n    \r\n    buildSpline: function(){\r\n        this.extrudePath = new THREE.Curve();\r\n        this.extrudePath.getPoint = function(t) {\r\n            t *= 2 * Math.PI;\r\n            var tx = 16 * Math.pow(Math.sin(t), 3);\r\n        \tvar ty = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t), tz = 0;\r\n        \r\n        \treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(50.0/16);\r\n        \r\n        }\r\n       \r\n\t    var geometry = new THREE.TubeGeometry(this.extrudePath, 300/*segments*/, 1/*radius*/, 6/*radiusSegments*/, true/*closed2*/, false/*debug*/);\r\n        return this.buildMeshFromGeometry(geometry, 0x0000ff);\r\n    }\r\n});\r\n\r\n\r\n\r\n"],[0,"\r\n\r\n"]],"start1":4245,"start2":4245,"length1":1559,"length2":8}]],"length":4253,"saved":false}
{"ts":1357159319600,"patch":[[{"diffs":[[0,"epres;\r\n        "],[1,"this.edges = [];\r\n        this.graph = new Graph();"],[0,"\r\n    },\r\n    \r\n"]],"start1":124,"start2":124,"length1":32,"length2":83}]],"length":4304,"saved":false}
{"ts":1357159322892,"patch":[[{"diffs":[[0,"h = new "],[1,"Game."],[0,"Graph();"]],"start1":175,"start2":175,"length1":16,"length2":21}]],"length":4309,"saved":false}
{"ts":1357159402129,"patch":[[{"diffs":[[0," = n"],[-1,"ew Game."],[1,"ull;\r\n        \r\n        this.decodeStringTo"],[0,"Grap"]],"start1":176,"start2":176,"length1":16,"length2":51}]],"length":4344,"saved":false}
{"ts":1357159471153,"patch":[[{"diffs":[[0,"    "],[-1,"handleSingleTick: function(){\r\n        \r\n    },\r\n    \r\n    handleCamera: function(){\r\n          \r\n    },\r\n    \r\n    alignBlockables: function(dir){\r\n          \r\n    },\r\n    \r\n    buildSpline: function(){\r\n          return null;\r\n    },\r\n    \r\n    buildMeshFromGeometry: function(geometry, color){\r\n        var tubeMesh = THREE.SceneUtils.createMultiMaterialObject(geometry, [\r\n\t\t    new THREE.MeshLambertMaterial({\r\n\t\t\t\t\t\tcolor: color,\r\n\t\t\t\t\t\topacity: (geometry.debug) ? 0.2 : 0.5,\r\n\t\t\t\t\t\ttransparent: true\r\n\t\t\t\t\t}),\r\n\t\t    new THREE.MeshBasicMaterial({\r\n\t\t\t\t\t\tcolor: color,\r\n\t\t\t\t\t\topacity: 0.5,\r\n\t\t\t\t\t\twireframe: true,\r\n                        transparent: true\r\n\t\t    })\r\n        ]);\r\n\r\n\t\tif (geometry.debug) tubeMesh.add(geometry.debug);  \r\n        return tubeMesh;\r\n    },\r\n    \r\n    buildBlockables: function(){\r\n        //this.material = new THREE.MeshPhongMaterial({color: 0xff0000, opacity: 0.8, wireframe: false, transparent: true});\r\n        this.material = new THREE.MeshBasicMaterial({color: 0xff0000});\r\n        this.blockables = [];\r\n        var geom = this.spline.children[0].geometry;\r\n        var path = geom.path;\r\n        var segments = geom.segments;\r\n        var segmentsRadius = geom.segmentsRadius;\r\n        var cylinderGeom = new THREE.CylinderGeometry( geom.radius/*radiusTop*/, geom.radius/*radiusBottom*/, 0.1/*height*/, segmentsRadius/*segmentsRadius*/, 1/*segmentsHeight*/, false/*openEnded*/ );\r\n        var availablePositions = [];\r\n        for(var j = 0; j < segmentsRadius; j++){\r\n            availablePositions.push(j);    \r\n        }\r\n        \r\n        for(var i = 0; i < segments; i++){\r\n            var directions = availablePositions.clone();\r\n            Game.Utils.arrayShuffle(directions);\r\n            \r\n            var rnd = Math.random();\r\n            if(rnd < 0.0015){\r\n                directions = directions.slice(0, -1);        // extract array from 0 to the second last (-1 = 1 counting from tail)  \r\n            }\r\n            else if(rnd < 0.005){\r\n                directions = directions.slice(0, -2);\r\n            }\r\n            else if(rnd < 0.01){\r\n                directions = directions.slice(0, -3);\r\n            }\r\n            else if(rnd < 0.02){\r\n                directions = directions.slice(0, -4);\r\n            }\r\n            else if(rnd < 0.025){\r\n                directions = directions.slice(0, -5);\r\n            }\r\n            else{\r\n                directions = [];   \r\n            }\r\n            \r\n            if(directions.length > 0){\r\n                var objects = [];\r\n                \r\n                var arcLengthPos = i/segments;\r\n                var pos = path.getPointAt(arcLengthPos);\r\n                var tangent = geom.tangents[i], normal = geom.normals[i], binormal = geom.binormals[i];\r\n                directions.each(function(dir, index){\r\n                    var obj = new THREE.Object3D();\r\n                    var mesh = new THREE.Mesh(cylinderGeom, this.material);\r\n                    mesh.rotation.x = 1.5*Math.PI;\r\n                    mesh.rotation.z = Math.PI/2;\r\n                    obj.add(mesh);\r\n                            \r\n                    // move in dir on spline\r\n                    var dirVector = Game.Utils.getVectorByDir(binormal, normal, dir, segmentsRadius);\r\n                    var offPos = pos.clone().addSelf(dirVector.normalize().multiplyScalar(1.75*geom.radius));\r\n                    obj.position.set(offPos.x, offPos.y, offPos.z);\r\n                            \r\n                    // rotate it correctly on spline\r\n                    var m = new THREE.Matrix4(tangent.x, normal.x, binormal.x, 0,\r\n                                                tangent.y, normal.y, binormal.y, 0,\r\n                                                tangent.z, normal.z, binormal.z);\r\n                    obj.rotation.getRotationFromMatrix(m);\r\n                            \r\n                    representation.scene.add(obj);\r\n                    objects[dir] = (obj); \r\n                }, this);\r\n                this.blockables[i] = objects;\r\n            }\r\n        }\r\n    }"],[1,"decodeStringToGraph: function(){\r\n        \r\n    }\r\n    "],[0,"\r\n})"]],"start1":247,"start2":247,"length1":4088,"length2":63}]],"length":319,"saved":false}
{"ts":1357160781389,"patch":[[{"diffs":[[0,"){\r\n        "],[1,"var c = 0;\r\n        var arr = this.stringRepresentation.split(\";\");\r\n        var dim = arr[0];"],[0,"\r\n    }\r\n   "]],"start1":281,"start2":281,"length1":24,"length2":118}]],"length":413,"saved":false}
{"ts":1357160841999,"patch":[[{"diffs":[[0,"plit(\";\");\r\n"],[1,"        if(arr.length < 1){\r\n            return;\r\n        }\r\n"],[0,"        var "]],"start1":350,"start2":350,"length1":24,"length2":85}]],"length":474,"saved":false}
{"ts":1357160953869,"patch":[[{"diffs":[[0," = arr[0];\r\n"],[1,"        if(dim != (arr.length - 1)*arr.length/2)\r\n"],[0,"    }\r\n    \r"]],"start1":438,"start2":438,"length1":24,"length2":74}]],"length":524,"saved":false}
{"ts":1357160985942,"patch":[[{"diffs":[[0,"ength/2)"],[1,"{\r\n            console.log(\"in Level:decodeStringToGraph: sizes do not match\");\r\n        }"],[0,"\r\n    }\r"]],"start1":490,"start2":490,"length1":16,"length2":106}]],"length":614,"saved":false}
{"ts":1357160994432,"patch":[[{"diffs":[[0,"t match\");\r\n"],[1,"            return;\r\n"],[0,"        }\r\n "]],"start1":567,"start2":567,"length1":24,"length2":45}]],"length":635,"saved":false}
{"ts":1357161011831,"patch":[[{"diffs":[[0,"\n        }\r\n"],[1,"        \r\n        var i = 0, j =0;\r\n"],[0,"    }\r\n    \r"]],"start1":599,"start2":599,"length1":24,"length2":60}]],"length":671,"saved":false}
{"ts":1357161055579,"patch":[[{"diffs":[[0," }\r\n"],[1,"\r\n"],[0,"        "],[-1,"\r\n"],[1,"for(var i = 0; i < dim; i++){\r\n   "],[0,"        "],[1," for("],[0,"var "],[-1,"i"],[1,"j"],[0," = 0"],[-1,", j =0;"],[1,"; j <= i; j++){\r\n            \r\n        }\r\n        }"],[0,"\r\n  "]],"start1":607,"start2":607,"length1":42,"length2":125}]],"length":754,"saved":false}
{"ts":1357161235803,"patch":[[{"diffs":[[0,"){\r\n"],[-1,"        var c = 0;\r\n"],[0,"    "]],"start1":281,"start2":281,"length1":28,"length2":8},{"diffs":[[0,"   }\r\n\r\n"],[1,"        var c = 1;\r\n"],[0,"        "]],"start1":585,"start2":585,"length1":16,"length2":36},{"diffs":[[0,"i = "],[-1,"0"],[1,"1"],[0,"; i <"],[1,"="],[0," dim"]],"start1":629,"start2":629,"length1":14,"length2":15},{"diffs":[[0,"var j = "],[-1,"0"],[1,"1"],[0,"; j <= i"]],"start1":669,"start2":669,"length1":17,"length2":17},{"diffs":[[0,"){\r\n            "],[-1,"\r\n"],[1,"    \r\n    "],[0,"        }\r\n     "]],"start1":691,"start2":691,"length1":34,"length2":42}]],"length":763,"saved":false}
{"ts":1357161253198,"patch":[[{"diffs":[[0,"   }\r\n\r\n"],[1,"        this.graph = new Game.Graph(dim);\r\n"],[0,"        "]],"start1":585,"start2":585,"length1":16,"length2":59}]],"length":806,"saved":false}
{"ts":1357161286917,"patch":[[{"diffs":[[0,"                "],[1,"this.graph.set(i,j, arr[c++]);"],[0,"\r\n            }\r"]],"start1":738,"start2":738,"length1":32,"length2":62}]],"length":836,"saved":false}
{"ts":1357161625012,"patch":[[{"diffs":[[0,"length/2"],[1," - dim){     // symmetric and no diagonal (-dim"],[0,")"],[-1,"{"],[0,"\r\n      "]],"start1":469,"start2":469,"length1":18,"length2":64},{"diffs":[[0,"= 1; j <"],[-1,"="],[0," i; j++)"]],"start1":764,"start2":764,"length1":17,"length2":16}]],"length":881,"saved":false}
